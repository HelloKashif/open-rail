<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>JSCAD Workshop</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      min-height: -webkit-fill-available;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    html {
      height: -webkit-fill-available;
    }
    header {
      background: #16213e;
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #0f3460;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    header h1 {
      font-size: 1.2rem;
      color: #e94560;
    }
    .controls {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      padding: 0.4rem 0.75rem;
      border: none;
      border-radius: 4px;
      font-size: 0.875rem;
      cursor: pointer;
      background: #e94560;
      color: #fff;
    }
    button:hover, button:active {
      background: #ff6b6b;
    }
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .editor-panel {
      width: 45%;
      display: flex;
      flex-direction: column;
      border-right: 2px solid #0f3460;
    }
    .panel-header {
      background: #16213e;
      padding: 0.5rem 0.75rem;
      font-weight: bold;
      font-size: 0.875rem;
      color: #e94560;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #code-editor {
      flex: 1;
      width: 100%;
      background: #0a0a15;
      color: #a8e6cf;
      font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
      font-size: 13px;
      padding: 0.75rem;
      border: none;
      resize: none;
      outline: none;
      line-height: 1.5;
    }
    .viewer-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #viewer-container {
      flex: 1;
      background: #2a2a4a;
      position: relative;
      touch-action: none;
      min-height: 300px;
    }
    #viewer-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
    .status-bar {
      background: #16213e;
      padding: 0.4rem 0.75rem;
      font-size: 0.75rem;
      color: #888;
      border-top: 1px solid #0f3460;
    }
    .status-bar.error { color: #ff6b6b; }
    .status-bar.success { color: #a8e6cf; }
    .help-text {
      font-size: 0.65rem;
      color: #666;
    }

    /* Mobile tabs */
    .mobile-tabs {
      display: none;
      background: #16213e;
      border-bottom: 2px solid #0f3460;
    }
    .mobile-tabs button {
      flex: 1;
      padding: 0.75rem;
      background: transparent;
      border: none;
      border-radius: 0;
      color: #888;
      font-size: 0.875rem;
    }
    .mobile-tabs button.active {
      background: #0f3460;
      color: #e94560;
    }

    /* Responsive */
    @media (max-width: 768px) {
      header {
        padding: 0.4rem 0.75rem;
      }
      header h1 {
        font-size: 1rem;
        width: 100%;
      }
      .controls {
        width: 100%;
        justify-content: space-between;
      }
      button {
        padding: 0.5rem 0.6rem;
        font-size: 0.8rem;
      }
      .mobile-tabs {
        display: flex;
      }
      .main-container {
        flex-direction: column;
      }
      .editor-panel {
        width: 100%;
        border-right: none;
        border-bottom: 2px solid #0f3460;
        flex: 1;
      }
      .editor-panel.hidden {
        display: none;
      }
      .viewer-panel {
        flex: 1;
        min-height: 50vh;
      }
      .viewer-panel.hidden {
        display: none;
      }
      .panel-header {
        display: none;
      }
      #code-editor {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>JSCAD Workshop</h1>
    <div class="controls">
      <button id="render-btn">Render</button>
      <button id="export-btn">Export STL</button>
    </div>
  </header>

  <div class="mobile-tabs">
    <button id="tab-code" class="active">Code</button>
    <button id="tab-view">3D View</button>
  </div>

  <div class="main-container">
    <div class="editor-panel" id="editor-panel">
      <div class="panel-header">Model Code</div>
      <textarea id="code-editor" spellcheck="false"></textarea>
    </div>
    <div class="viewer-panel" id="viewer-panel">
      <div class="panel-header">
        <span>3D Preview</span>
        <span class="help-text">Drag: rotate | Scroll: zoom | Shift+drag: pan</span>
      </div>
      <div id="viewer-container"></div>
    </div>
  </div>

  <div id="status-bar" class="status-bar">Loading...</div>

  <!-- Three.js for 3D rendering (older version with non-module controls) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

  <!-- JSCAD for modeling -->
  <script src="https://unpkg.com/@jscad/modeling@2.12.2/dist/jscad-modeling.min.js"></script>

  <script>
    // Get JSCAD modeling module
    const modeling = jscadModeling;

    // Destructure commonly used functions
    const { cube, cuboid, sphere, cylinder, cylinderElliptic, torus, polygon, circle, rectangle, roundedCuboid, roundedCylinder } = modeling.primitives;
    const { extrudeLinear, extrudeRotate } = modeling.extrusions;
    const { union, subtract, intersect } = modeling.booleans;
    const { translate, rotate, rotateX, rotateY, rotateZ, scale, center, align, mirror, mirrorX, mirrorY, mirrorZ } = modeling.transforms;
    const { colorize } = modeling.colors;
    const { hull, hullChain } = modeling.hulls;
    const { degToRad } = modeling.utils;
    const { path2, geom2, geom3 } = modeling.geometries;

    // Default sample code
    const sampleCode = `// HO Scale Rail Profile Generator
// Scale: 1:87 (HO)
// Rail codes: 100 (2.54mm), 83 (2.11mm), 70 (1.78mm)

// ============ PARAMETERS ============
const railCode = 100;  // Change to 100, 83, or 70
const railLength = 50; // mm

// HO scale track gauge: 16.5mm between inner edges of rail heads
// This represents 1435mm (standard gauge) at 1:87 scale
const trackGauge = 16.5; // mm (inner edge to inner edge)

// HO scale tie (sleeper) dimensions
// Real ties: ~2590mm long, 178mm wide, 152mm tall
// At 1:87 scale:
const tieLength = 30;    // mm (across track, X direction)
const tieWidth = 2.0;    // mm (along track, Y direction)
const tieHeight = 1.7;   // mm (thickness, Z direction)
const tieSpacing = 13;   // mm center-to-center (prototype ~21" = 533mm)

// Rail specs based on code (mm)
const railSpecs = {
  100: { height: 2.54, headWidth: 1.8, headHeight: 0.7, webThickness: 0.5, baseWidth: 3.0, baseHeight: 0.6 },
  83:  { height: 2.11, headWidth: 1.5, headHeight: 0.6, webThickness: 0.4, baseWidth: 2.5, baseHeight: 0.5 },
  70:  { height: 1.78, headWidth: 1.3, headHeight: 0.5, webThickness: 0.35, baseWidth: 2.1, baseHeight: 0.45 }
};

const spec = railSpecs[railCode];

// ============ RAIL PROFILE (I-beam) ============
const halfHead = spec.headWidth / 2;
const halfWeb = spec.webThickness / 2;
const halfBase = spec.baseWidth / 2;
const webHeight = spec.height - spec.headHeight - spec.baseHeight;

// Fillet radius for the head top corners
const filletRadius = spec.headHeight * 0.5;
const filletSegments = 6;

// Generate fillet arc points
function filletArc(centerX, centerY, radius, startAngle, endAngle, segments) {
  const points = [];
  for (let i = 0; i <= segments; i++) {
    const angle = startAngle + (endAngle - startAngle) * (i / segments);
    points.push([
      centerX + radius * Math.cos(angle),
      centerY + radius * Math.sin(angle)
    ]);
  }
  return points;
}

// Right fillet (top-right corner)
const rightFilletCenter = [halfHead - filletRadius, spec.height - filletRadius];
const rightFillet = filletArc(rightFilletCenter[0], rightFilletCenter[1], filletRadius, 0, Math.PI/2, filletSegments);

// Left fillet (top-left corner)
const leftFilletCenter = [-halfHead + filletRadius, spec.height - filletRadius];
const leftFillet = filletArc(leftFilletCenter[0], leftFilletCenter[1], filletRadius, Math.PI/2, Math.PI, filletSegments);

// Profile points (clockwise from bottom-left)
const profilePoints = [
  // Base
  [-halfBase, 0], [halfBase, 0], [halfBase, spec.baseHeight],
  // Right side up to web
  [halfWeb, spec.baseHeight],
  [halfWeb, spec.baseHeight + webHeight],
  // Right side of head
  [halfHead, spec.baseHeight + webHeight],
  [halfHead, spec.height - filletRadius],
  // Right fillet (curved top-right)
  ...rightFillet,
  // Left fillet (curved top-left)
  ...leftFillet,
  // Left side of head
  [-halfHead, spec.height - filletRadius],
  [-halfHead, spec.baseHeight + webHeight],
  // Left side down to web
  [-halfWeb, spec.baseHeight + webHeight],
  [-halfWeb, spec.baseHeight],
  // Back to base
  [-halfBase, spec.baseHeight]
];

// Create 2D profile (in XZ plane) and extrude along Y
const railProfile2D = polygon({ points: profilePoints });
const rail = extrudeLinear({ height: railLength }, railProfile2D);

// Rotate so: profile is in XZ plane, length along Y axis
// Rail sits on XY plane with height going up in Z
const rotated = rotateX(degToRad(-90), rail);
const singleRail = translate([0, railLength/2, 0], rotated);

// Calculate center-to-center distance for correct gauge
// Gauge is measured between inner edges of heads
const centerToCenter = trackGauge + spec.headWidth;

// Create left and right rails
const leftRail = translate([-centerToCenter/2, 0, 0], singleRail);
const rightRail = translate([centerToCenter/2, 0, 0], singleRail);

// Steel gray color for rails
const coloredLeft = colorize([0.45, 0.45, 0.48], leftRail);
const coloredRight = colorize([0.45, 0.45, 0.48], rightRail);

// ============ CREATE TIES ============
// Create a single tie (centered at origin)
const singleTie = cuboid({
  size: [tieLength, tieWidth, tieHeight],
  center: [0, 0, tieHeight/2]  // Sit on Z=0
});

// Calculate number of ties needed
const numTies = Math.floor(railLength / tieSpacing);

// Generate ties along the track
const ties = [];
for (let i = 0; i <= numTies; i++) {
  const yPos = i * tieSpacing;
  const tie = translate([0, yPos, 0], singleTie);
  ties.push(tie);
}

// Combine all ties and color them (wood brown)
const allTies = union(...ties);
const coloredTies = colorize([0.4, 0.26, 0.13], allTies);

// Move rails up to sit on top of ties
const railZ = tieHeight; // Rails sit on top of ties
const raisedLeft = translate([0, 0, railZ], coloredLeft);
const raisedRight = translate([0, 0, railZ], coloredRight);

return [raisedLeft, raisedRight, coloredTies];`;

    // State
    let currentSolids = [];
    let scene, camera, renderer, controls;
    let currentMesh = null;

    // DOM elements
    const codeEditor = document.getElementById('code-editor');
    const viewerContainer = document.getElementById('viewer-container');
    const statusBar = document.getElementById('status-bar');
    const renderBtn = document.getElementById('render-btn');
    const exportBtn = document.getElementById('export-btn');
    const editorPanel = document.getElementById('editor-panel');
    const viewerPanel = document.getElementById('viewer-panel');
    const tabCode = document.getElementById('tab-code');
    const tabView = document.getElementById('tab-view');

    // Mobile tab switching
    function setupMobileTabs() {
      tabCode.addEventListener('click', () => {
        tabCode.classList.add('active');
        tabView.classList.remove('active');
        editorPanel.classList.remove('hidden');
        viewerPanel.classList.add('hidden');
      });

      tabView.addEventListener('click', () => {
        tabView.classList.add('active');
        tabCode.classList.remove('active');
        viewerPanel.classList.remove('hidden');
        editorPanel.classList.add('hidden');
        setTimeout(() => onWindowResize(), 50);
      });

      if (window.innerWidth <= 768) {
        tabView.classList.add('active');
        tabCode.classList.remove('active');
        viewerPanel.classList.remove('hidden');
        editorPanel.classList.add('hidden');
      }
    }

    // Initialize Three.js scene
    function initThreeJS() {
      const width = viewerContainer.clientWidth;
      const height = viewerContainer.clientHeight;

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x2a2a4a);

      // Camera - positioned to view rail lying flat in XY plane
      camera = new THREE.PerspectiveCamera(45, width / height, 0.01, 10000);
      camera.position.set(40, -60, 40);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      viewerContainer.appendChild(renderer.domElement);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 100, 50);
      scene.add(directionalLight);

      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight2.position.set(-50, -50, -50);
      scene.add(directionalLight2);

      // Grid - smaller for HO scale (each square = 10mm)
      const gridHelper = new THREE.GridHelper(200, 40, 0x444466, 0x333355);
      gridHelper.rotation.x = Math.PI / 2;
      scene.add(gridHelper);

      // Axes
      const axesHelper = new THREE.AxesHelper(30);
      scene.add(axesHelper);

      // Handle resize
      window.addEventListener('resize', onWindowResize);

      // Animation loop
      animate();
    }

    function onWindowResize() {
      const width = viewerContainer.clientWidth;
      const height = viewerContainer.clientHeight;
      if (width > 0 && height > 0) {
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Convert JSCAD geometry to Three.js mesh
    function jscadToThreejs(solid) {
      const polygons = modeling.geometries.geom3.toPolygons(solid);
      const geometry = new THREE.BufferGeometry();

      const vertices = [];
      const normals = [];
      const colors = [];

      // Get color from solid if available
      let color = [0.5, 0.5, 0.8]; // default color
      if (solid.color) {
        color = solid.color;
      }

      for (const polygon of polygons) {
        const verts = polygon.vertices;

        // Triangulate polygon (fan triangulation)
        for (let i = 1; i < verts.length - 1; i++) {
          const v0 = verts[0];
          const v1 = verts[i];
          const v2 = verts[i + 1];

          vertices.push(v0[0], v0[1], v0[2]);
          vertices.push(v1[0], v1[1], v1[2]);
          vertices.push(v2[0], v2[1], v2[2]);

          // Calculate normal
          const edge1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
          const edge2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];
          const normal = [
            edge1[1] * edge2[2] - edge1[2] * edge2[1],
            edge1[2] * edge2[0] - edge1[0] * edge2[2],
            edge1[0] * edge2[1] - edge1[1] * edge2[0]
          ];
          const len = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
          normal[0] /= len; normal[1] /= len; normal[2] /= len;

          for (let j = 0; j < 3; j++) {
            normals.push(normal[0], normal[1], normal[2]);
            colors.push(color[0], color[1], color[2]);
          }
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const material = new THREE.MeshPhongMaterial({
        vertexColors: true,
        side: THREE.DoubleSide,
        flatShading: false
      });

      return new THREE.Mesh(geometry, material);
    }

    // Render the model from code
    function renderModel() {
      try {
        const code = codeEditor.value;

        // Create a function from the code
        const fn = new Function(
          'cube', 'cuboid', 'sphere', 'cylinder', 'cylinderElliptic', 'torus', 'polygon', 'circle', 'rectangle', 'roundedCuboid', 'roundedCylinder',
          'extrudeLinear', 'extrudeRotate',
          'union', 'subtract', 'intersect',
          'translate', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'center', 'align', 'mirror', 'mirrorX', 'mirrorY', 'mirrorZ',
          'colorize', 'hull', 'hullChain', 'degToRad',
          'path2', 'geom2', 'geom3',
          'modeling',
          code
        );

        let result = fn(
          cube, cuboid, sphere, cylinder, cylinderElliptic, torus, polygon, circle, rectangle, roundedCuboid, roundedCylinder,
          extrudeLinear, extrudeRotate,
          union, subtract, intersect,
          translate, rotate, rotateX, rotateY, rotateZ, scale, center, align, mirror, mirrorX, mirrorY, mirrorZ,
          colorize, hull, hullChain, degToRad,
          path2, geom2, geom3,
          modeling
        );

        // Handle single solid or array
        currentSolids = Array.isArray(result) ? result : [result];

        // Remove old mesh
        if (currentMesh) {
          scene.remove(currentMesh);
          currentMesh.geometry.dispose();
          currentMesh.material.dispose();
        }

        // Create group for multiple solids
        currentMesh = new THREE.Group();

        for (const solid of currentSolids) {
          const mesh = jscadToThreejs(solid);
          currentMesh.add(mesh);
        }

        scene.add(currentMesh);

        setStatus('Rendered successfully!', 'success');
      } catch (err) {
        console.error(err);
        setStatus('Error: ' + err.message, 'error');
      }
    }

    // Set status bar message
    function setStatus(msg, type = '') {
      statusBar.textContent = msg;
      statusBar.className = 'status-bar' + (type ? ' ' + type : '');
    }

    // Export to STL
    function exportSTL() {
      if (!currentMesh || currentMesh.children.length === 0) {
        setStatus('Nothing to export!', 'error');
        return;
      }

      try {
        const exporter = new THREE.STLExporter();
        const stlString = exporter.parse(currentMesh, { binary: true });
        const blob = new Blob([stlString], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'model.stl';
        a.click();

        URL.revokeObjectURL(url);
        setStatus('Exported model.stl', 'success');
      } catch (err) {
        setStatus('Export error: ' + err.message, 'error');
      }
    }

    // Setup event listeners
    function setupEventListeners() {
      renderBtn.addEventListener('click', renderModel);
      exportBtn.addEventListener('click', exportSTL);

      // Ctrl+Enter to render
      codeEditor.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'Enter') {
          e.preventDefault();
          renderModel();
        }
      });
    }

    // Initialize
    function init() {
      codeEditor.value = sampleCode;
      setupMobileTabs();
      setupEventListeners();

      setTimeout(() => {
        initThreeJS();
        renderModel();
      }, 100);
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
